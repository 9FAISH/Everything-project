import logging
import asyncio
import json
import re
import subprocess
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
import requests
from models import Device, Vulnerability, ThreatLevel, ScanResult, ScanType

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Ethical vulnerability scanner using signature-based detection and CVE databases"""
    
    def __init__(self):
        self.cve_api_base = "https://cve.circl.lu/api"
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.timeout = 30
        
        # Known vulnerable service patterns
        self.vulnerability_patterns = {
            'ssh': {
                'OpenSSH_7.4': {'cve': 'CVE-2018-15473', 'severity': 'medium'},
                'OpenSSH_6.6': {'cve': 'CVE-2016-0777', 'severity': 'high'},
                'OpenSSH_5.3': {'cve': 'CVE-2010-4478', 'severity': 'medium'},
            },
            'apache': {
                'Apache/2.4.17': {'cve': 'CVE-2016-5387', 'severity': 'high'},
                'Apache/2.2.22': {'cve': 'CVE-2012-0053', 'severity': 'medium'},
            },
            'nginx': {
                'nginx/1.10.0': {'cve': 'CVE-2016-4450', 'severity': 'medium'},
                'nginx/1.4.0': {'cve': 'CVE-2013-4547', 'severity': 'medium'},
            },
            'smb': {
                'Samba_3.0.20': {'cve': 'CVE-2007-2447', 'severity': 'critical'},
                'Samba_3.5.0': {'cve': 'CVE-2012-1182', 'severity': 'high'},
            },
            'ftp': {
                'vsftpd_2.3.4': {'cve': 'CVE-2011-2523', 'severity': 'critical'},
                'ProFTPD_1.3.3c': {'cve': 'CVE-2010-4221', 'severity': 'high'},
            }
        }

    async def scan_device_vulnerabilities(self, device: Device, scan_options: Dict[str, Any] = None) -> Tuple[List[Vulnerability], Dict[str, Any]]:
        """
        Scan a device for known vulnerabilities
        
        Args:
            device: Device to scan
            scan_options: Additional scan configuration
            
        Returns:
            Tuple of (vulnerabilities found, scan metadata)
        """
        vulnerabilities = []
        scan_metadata = {
            'device_id': device.id,
            'device_ip': device.ip_address,
            'scan_started': datetime.utcnow(),
            'techniques_used': [],
            'services_analyzed': []
        }
        
        try:
            logger.info(f"Starting vulnerability scan for device {device.ip_address}")
            
            # Service-based vulnerability detection
            service_vulns = await self._scan_service_vulnerabilities(device)
            vulnerabilities.extend(service_vulns)
            scan_metadata['techniques_used'].append('service_fingerprinting')
            
            # Port-based vulnerability checks
            port_vulns = await self._scan_port_vulnerabilities(device)
            vulnerabilities.extend(port_vulns)
            scan_metadata['techniques_used'].append('port_analysis')
            
            # Configuration vulnerability checks
            config_vulns = await self._scan_configuration_vulnerabilities(device)
            vulnerabilities.extend(config_vulns)
            scan_metadata['techniques_used'].append('configuration_analysis')
            
            # SSL/TLS vulnerability checks
            if any(port in device.open_ports for port in [443, 993, 995, 465, 587]):
                ssl_vulns = await self._scan_ssl_vulnerabilities(device)
                vulnerabilities.extend(ssl_vulns)
                scan_metadata['techniques_used'].append('ssl_analysis')
            
            # SMB vulnerability checks
            if 445 in device.open_ports or 139 in device.open_ports:
                smb_vulns = await self._scan_smb_vulnerabilities(device)
                vulnerabilities.extend(smb_vulns)
                scan_metadata['techniques_used'].append('smb_analysis')
            
            scan_metadata['scan_completed'] = datetime.utcnow()
            scan_metadata['vulnerabilities_found'] = len(vulnerabilities)
            scan_metadata['duration'] = (scan_metadata['scan_completed'] - scan_metadata['scan_started']).total_seconds()
            
            logger.info(f"Vulnerability scan completed for {device.ip_address}. Found {len(vulnerabilities)} vulnerabilities.")
            return vulnerabilities, scan_metadata
            
        except Exception as e:
            logger.error(f"Vulnerability scan failed for {device.ip_address}: {e}")
            scan_metadata['error'] = str(e)
            scan_metadata['scan_completed'] = datetime.utcnow()
            return vulnerabilities, scan_metadata

    async def _scan_service_vulnerabilities(self, device: Device) -> List[Vulnerability]:
        """Scan for vulnerabilities based on service versions"""
        vulnerabilities = []
        
        for port_str, service_info in device.services.items():
            try:
                port = int(port_str)
                service_name = service_info.get('name', '').lower()
                product = service_info.get('product', '')
                version = service_info.get('version', '')
                
                # Check against known vulnerability patterns
                if service_name in self.vulnerability_patterns:
                    service_key = f"{product}/{version}" if product and version else version
                    
                    for pattern, vuln_info in self.vulnerability_patterns[service_name].items():
                        if pattern.lower() in service_key.lower():
                            vulnerability = Vulnerability(
                                device_id=device.id,
                                cve_id=vuln_info['cve'],
                                title=f"Vulnerable {product} {version} detected",
                                description=f"Known vulnerability in {product} {version} running on port {port}",
                                severity=ThreatLevel(vuln_info['severity']),
                                affected_service=f"{product} {version}",
                                port=port,
                                solution=f"Update {product} to latest version"
                            )
                            vulnerabilities.append(vulnerability)
                
                # Check for default credentials
                default_cred_vuln = await self._check_default_credentials(device, port, service_name)
                if default_cred_vuln:
                    vulnerabilities.append(default_cred_vuln)
                    
            except Exception as e:
                logger.warning(f"Error analyzing service on port {port_str}: {e}")
                continue
        
        return vulnerabilities

    async def _scan_port_vulnerabilities(self, device: Device) -> List[Vulnerability]:
        """Scan for vulnerabilities based on open ports"""
        vulnerabilities = []
        
        # Check for dangerous/unnecessary open ports
        dangerous_ports = {
            21: "FTP - Consider using SFTP/FTPS",
            23: "Telnet - Use SSH instead",
            135: "RPC - Often targeted by attackers",
            139: "NetBIOS - Unnecessary if SMB over TCP/IP is available", 
            445: "SMB - Ensure proper authentication and patching",
            1433: "SQL Server - Should not be exposed to internet",
            3389: "RDP - High risk if exposed to internet",
            5432: "PostgreSQL - Database should not be publicly accessible",
            3306: "MySQL - Database should not be publicly accessible"
        }
        
        for port in device.open_ports:
            if port in dangerous_ports:
                severity = ThreatLevel.HIGH if port in [21, 23, 1433, 3306, 5432] else ThreatLevel.MEDIUM
                
                vulnerability = Vulnerability(
                    device_id=device.id,
                    title=f"Potentially dangerous service on port {port}",
                    description=f"Port {port} is open: {dangerous_ports[port]}",
                    severity=severity,
                    port=port,
                    solution=f"Review necessity of service on port {port} and implement proper security controls"
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    async def _scan_configuration_vulnerabilities(self, device: Device) -> List[Vulnerability]:
        """Scan for configuration-based vulnerabilities"""
        vulnerabilities = []
        
        # Check for too many open ports (potential misconfiguration)
        if len(device.open_ports) > 20:
            vulnerability = Vulnerability(
                device_id=device.id,
                title="Excessive open ports detected",
                description=f"Device has {len(device.open_ports)} open ports, which may indicate misconfiguration or compromise",
                severity=ThreatLevel.MEDIUM,
                solution="Review and close unnecessary services and ports"
            )
            vulnerabilities.append(vulnerability)
        
        # Check for common administrative ports exposed
        admin_ports = [22, 23, 80, 443, 8080, 8443, 9090]
        exposed_admin_ports = [p for p in admin_ports if p in device.open_ports]
        
        if len(exposed_admin_ports) >= 3:
            vulnerability = Vulnerability(
                device_id=device.id,
                title="Multiple administrative interfaces exposed",
                description=f"Administrative ports detected: {exposed_admin_ports}",
                severity=ThreatLevel.MEDIUM,
                solution="Implement proper access controls and consider VPN access for administrative interfaces"
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    async def _scan_ssl_vulnerabilities(self, device: Device) -> List[Vulnerability]:
        """Scan for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        ssl_ports = [port for port in device.open_ports if port in [443, 993, 995, 465, 587]]
        
        for port in ssl_ports:
            try:
                # Simple SSL/TLS check using OpenSSL
                result = subprocess.run([
                    'timeout', '10', 'openssl', 's_client', '-connect', f"{device.ip_address}:{port}"
                ], capture_output=True, text=True, timeout=15)
                
                if result.returncode == 0:
                    output = result.stdout.lower()
                    
                    # Check for weak protocols
                    if 'sslv2' in output or 'sslv3' in output:
                        vulnerability = Vulnerability(
                            device_id=device.id,
                            title=f"Weak SSL/TLS protocol on port {port}",
                            description="Outdated SSL/TLS protocols (SSLv2/SSLv3) are vulnerable to attacks",
                            severity=ThreatLevel.HIGH,
                            port=port,
                            solution="Disable SSLv2 and SSLv3, use TLS 1.2 or higher"
                        )
                        vulnerabilities.append(vulnerability)
                    
                    # Check for weak ciphers
                    weak_ciphers = ['rc4', 'des', 'md5', 'export']
                    for cipher in weak_ciphers:
                        if cipher in output:
                            vulnerability = Vulnerability(
                                device_id=device.id,
                                title=f"Weak cipher detected on port {port}",
                                description=f"Weak cipher suite containing {cipher.upper()} detected",
                                severity=ThreatLevel.MEDIUM,
                                port=port,
                                solution="Configure strong cipher suites and disable weak encryption"
                            )
                            vulnerabilities.append(vulnerability)
                            break
                            
            except Exception as e:
                logger.warning(f"SSL scan failed for {device.ip_address}:{port}: {e}")
                continue
        
        return vulnerabilities

    async def _scan_smb_vulnerabilities(self, device: Device) -> List[Vulnerability]:
        """Scan for SMB-related vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for SMB version and known vulnerabilities
            result = subprocess.run([
                'timeout', '10', 'smbclient', '-L', f"//{device.ip_address}", '-N'
            ], capture_output=True, text=True, timeout=15)
            
            if result.returncode == 0:
                output = result.stdout + result.stderr
                
                # Check for SMBv1
                if 'smb1' in output.lower() or 'nt lm 0.12' in output.lower():
                    vulnerability = Vulnerability(
                        device_id=device.id,
                        cve_id="CVE-2017-0144",  # EternalBlue
                        title="SMBv1 protocol enabled",
                        description="SMBv1 is vulnerable to multiple exploits including EternalBlue",
                        severity=ThreatLevel.CRITICAL,
                        port=445,
                        solution="Disable SMBv1 and upgrade to SMBv2/SMBv3"
                    )
                    vulnerabilities.append(vulnerability)
                
                # Check for null session
                null_result = subprocess.run([
                    'timeout', '5', 'smbclient', '-L', f"//{device.ip_address}", '-N', '-U', '""'
                ], capture_output=True, text=True, timeout=10)
                
                if null_result.returncode == 0 and 'sharename' in null_result.stdout.lower():
                    vulnerability = Vulnerability(
                        device_id=device.id,
                        title="SMB null session allowed",
                        description="SMB server allows anonymous connections",
                        severity=ThreatLevel.HIGH,
                        port=445,
                        solution="Disable null sessions and require authentication"
                    )
                    vulnerabilities.append(vulnerability)
                    
        except Exception as e:
            logger.warning(f"SMB scan failed for {device.ip_address}: {e}")
        
        return vulnerabilities

    async def _check_default_credentials(self, device: Device, port: int, service: str) -> Optional[Vulnerability]:
        """Check for default credentials on common services"""
        default_creds = {
            'ssh': [('admin', 'admin'), ('root', 'root'), ('admin', ''), ('root', '')],
            'ftp': [('anonymous', ''), ('ftp', 'ftp'), ('admin', 'admin')],
            'telnet': [('admin', 'admin'), ('root', 'root'), ('admin', '')],
            'http': [('admin', 'admin'), ('admin', 'password'), ('admin', '')],
        }
        
        if service in default_creds:
            # Note: This is a placeholder - actual credential testing would require
            # careful implementation to avoid account lockouts and comply with
            # ethical hacking guidelines
            
            # For now, we flag the presence of these services as potential risks
            return Vulnerability(
                device_id=device.id,
                title=f"Default credentials possible on {service.upper()}",
                description=f"{service.upper()} service detected - verify default credentials are not in use",
                severity=ThreatLevel.MEDIUM,
                port=port,
                solution=f"Ensure default credentials are changed for {service.upper()} service"
            )
        
        return None

    async def get_cve_details(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Fetch CVE details from public databases"""
        try:
            # Try CIRCL CVE API first
            response = requests.get(f"{self.cve_api_base}/cve/{cve_id}", timeout=self.timeout)
            if response.status_code == 200:
                return response.json()
            
            # Try NVD API as backup
            response = requests.get(f"{self.nvd_api_base}?cveId={cve_id}", timeout=self.timeout)
            if response.status_code == 200:
                data = response.json()
                if data.get('vulnerabilities'):
                    return data['vulnerabilities'][0]['cve']
                    
        except Exception as e:
            logger.warning(f"Failed to fetch CVE details for {cve_id}: {e}")
        
        return None

    async def calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Calculate overall risk score for a set of vulnerabilities"""
        if not vulnerabilities:
            return {'risk_score': 0, 'risk_level': 'LOW', 'summary': 'No vulnerabilities detected'}
        
        # Weight vulnerabilities by severity
        severity_weights = {
            ThreatLevel.CRITICAL: 10,
            ThreatLevel.HIGH: 7,
            ThreatLevel.MEDIUM: 4,
            ThreatLevel.LOW: 1,
            ThreatLevel.INFO: 0
        }
        
        total_score = 0
        severity_counts = {level: 0 for level in ThreatLevel}
        
        for vuln in vulnerabilities:
            total_score += severity_weights[vuln.severity]
            severity_counts[vuln.severity] += 1
        
        # Normalize score (0-100)
        max_possible_score = len(vulnerabilities) * 10
        normalized_score = min(100, (total_score / max_possible_score) * 100) if max_possible_score > 0 else 0
        
        # Determine risk level
        if normalized_score >= 80:
            risk_level = 'CRITICAL'
        elif normalized_score >= 60:
            risk_level = 'HIGH'
        elif normalized_score >= 30:
            risk_level = 'MEDIUM'
        elif normalized_score > 0:
            risk_level = 'LOW'
        else:
            risk_level = 'MINIMAL'
        
        return {
            'risk_score': round(normalized_score, 2),
            'risk_level': risk_level,
            'total_vulnerabilities': len(vulnerabilities),
            'severity_breakdown': {level.value: count for level, count in severity_counts.items()},
            'summary': f"Risk assessment complete: {len(vulnerabilities)} vulnerabilities found"
        }